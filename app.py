from flask import Flask, render_template, redirect, url_for, flash, request, session
from flask_sqlalchemy import SQLAlchemy
from flask_wtf import FlaskForm
from wtforms import StringField, PasswordField, SubmitField
from wtforms.validators import DataRequired, Length
import os
import subprocess 
import pygetwindow as gw
import requests
from threading import Thread

import logging
from logging.handlers import RotatingFileHandler
# from flask_fontawesome import FontAwesome

from models import db, User, UploadedFile, Report
from forms import RegistrationForm, LoginForm, UploadForm  # Add this line to import the form classes
from datetime import datetime

from flask import jsonify
import time

# Some default / base configurations 
app = Flask(__name__)
app.config['SECRET_KEY'] = 'your_secret_key'
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///site.db'
app.config['UPLOAD_FOLDER'] = 'uploads'
db.init_app(app)

remnux_vm='REMnux'
flare_vm='Flarevm'

# Configure logging
logging.basicConfig(level=logging.INFO)
handler = RotatingFileHandler('app.log', maxBytes=10000, backupCount=1)
handler.setLevel(logging.INFO)
app.logger.addHandler(handler)

# ROUTING TO THE VARIOUS PAGES
@app.route('/')
def home():
    if 'username' in session:
        # Redirect to the dashboard or another page for logged-in users
        return redirect(url_for('dashboard'))
    return redirect(url_for('login'))

@app.route('/autoscan')
def autoscan():
    if 'username' not in session:
        flash('You are not logged in', 'error')
        return redirect(url_for('login'))

    username = session['username']
    files = UploadedFile.query.filter_by(user=username).all()
    for file in files:
        file.date_uploaded = file.date_uploaded.strftime('%Y-%m-%d %H:%M')
        if file.file_size >= 1024 * 1024:  # File size is in bytes, convert to MB
            file.file_size = f"{file.file_size / (1024 * 1024):.2f} MB"
        else:  # File size is in bytes, convert to KB
            file.file_size = f"{file.file_size / 1024:.2f} KB"
    return render_template('autoscan.html', files=files)

# @app.route('/view_report/<int:file_id>', methods=['POST'])
# def view_report(file_id):
#     # Fetch the file from the database using the file_id
#     uploaded_file = UploadedFile.query.get(file_id)
#     if not uploaded_file:
#         abort(404)
    
    # Render the report template with the report data
    # return render_template('report.html', report=json.loads(uploaded_file.report))
    
@app.route('/history')
def history():
    # Add your logic for the History page here
    return render_template('history.html')

@app.route('/dashboard', methods=['GET', 'POST'])
def dashboard():
    upload_form = UploadForm()

    if request.method == 'POST' and upload_form.validate_on_submit():
        malware_file = request.files['malware_file']

        if malware_file:
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], malware_file.filename)
            malware_file.save(file_path)
            flash(f'Malware file "{malware_file.filename}" uploaded successfully!', 'success')
        else:
            flash('No file selected for upload.', 'danger')

     # Get information about VMs
    vm_info = get_vm_info()

    return render_template('dashboard.html', upload_form=upload_form, vm_info=vm_info)


# --- START AUTOSCAN PAGE  ----:
from werkzeug.utils import secure_filename

# Define a function to check if the file is allowed
ALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'}

def allowed_file(filename):
    # [for specific file types ]
    # return '.' in filename and \
    #        filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS
    # [ For all file types ]
    return True  # Allow all file extensions


# Update the upload_file route
@app.route('/upload_file', methods=['POST'])
def upload_file():
    if 'file' not in request.files:
        flash('No file part', 'error')
        return redirect(request.url)
    
    file = request.files['file']
    
    if file.filename == '':
        flash('You have not selected a file', 'error')
        return redirect(request.url)
    
    if file and allowed_file(file.filename):
        filename = secure_filename(file.filename)
        try:
            file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))
            # Save file details to the database
            uploaded_file = UploadedFile(
                file_path=os.path.join(app.config['UPLOAD_FOLDER'], filename),
                date_uploaded=datetime.now(),
                user=session['username'],  # Assuming user is stored in the session
                file_type=file.mimetype,
                file_size=os.path.getsize(os.path.join(app.config['UPLOAD_FOLDER'], filename)),
                status='unscanned'
            )
            db.session.add(uploaded_file)
            db.session.commit()
            flash('File uploaded successfully', 'success')
            app.logger.info(f"File '{filename}' saved to uploads folder")
            return redirect(url_for('autoscan'))
        except Exception as e:
            app.logger.error(f"Error saving file '{filename}': {e}")
            flash('Error uploading file', 'error')
            return redirect(request.url)
    else:
        flash('Invalid file type', 'error')
        return redirect(request.url)



# Deleting a file :
@app.route('/delete_file/<int:id>', methods=['POST'])
def delete_file(id):
    file = UploadedFile.query.get_or_404(id)
    if file.delete_file():
        flash('File deleted successfully', 'success')
    else:
        flash('Error deleting file', 'error')
    return redirect(url_for('autoscan'))


@app.route('/start_scan/<int:file_id>', methods=['POST'])
def start_scan(file_id):
    # Get the file from the database
    file = UploadedFile.query.get(file_id)
    
    # Read the API key from the file
    with open('vt-api.txt', 'r') as f:
        api_key = f.read().strip()

    # Define the URL and headers for the VirusTotal API request
    url = 'https://www.virustotal.com/api/v3/files'
    headers = {
        'x-apikey': api_key
    }
    
    # Open the file and send it to VirusTotal for scanning
    with open(file.file_path, 'rb') as f:
        response = requests.post(url, headers=headers, files={'file': f})

    # Parse the JSON response
    data = response.json()

    # Check if the file was successfully uploaded for scanning
    if 'error' in data:
        return jsonify(success=False, error=data['error']['message'])

    # Initialize a variable to track the scan status
    scan_status = 'queued'

    # Keep checking the scan status until it is no longer 'queued'
    while scan_status == 'queued':
        time.sleep(10)  # Wait for 10 seconds before checking again
        response = requests.get('https://www.virustotal.com/api/v3/analyses/' + data['data']['id'], headers=headers)
        data = response.json()
        scan_status = data.get('data', {}).get('attributes', {}).get('status')

    # Create a new report and save it to the database
    report = Report(
        file_id=file_id,
        user_id=session['username'],  # Assuming the username is stored in the session
        timestamp=datetime.utcnow(),
        report=json.dumps(data)
    )
    
    db.session.add(report)
    
    file.status = 'scanned'
    db.session.commit()

    # Return a success message
     # Update the page with the scan results
    scan_results = data  # Assuming the data contains the scan results
    # Update the status of the file to 'scanned'
  
    return redirect(url_for('autoscan'))

@app.route('/view_report/<int:file_id>')
def view_report(file_id):
    # Assuming `report_data` contains the raw JSON data retrieved from the database
    report_data = get_report_data(file_id)

    # Parse the JSON data into a Python dictionary
    report_dict = json.loads(report_data)

    return render_template('view_report.html', report=report_dict)

def get_report_data(file_id):
    # Query the Report table
    report = Report.query.filter_by(file_id=file_id).first()

    # Check if a report exists for the given file_id
    if report is not None:
        return report.report
    else:
        return None
    
@app.route('/register', methods=['GET', 'POST'])
def register():
    form = RegistrationForm()

    if form.validate_on_submit():
        existing_user = User.query.filter_by(username=form.username.data).first()

        if existing_user:
            flash('Username is already taken. Please choose a different one.', 'danger')
        else:
            user = User(username=form.username.data, password=form.password.data)
            db.session.add(user)
            db.session.commit()
            flash('Your account has been created! You can now log in.', 'success')
            return redirect(url_for('login'))

    return render_template('register.html', form=form)


@app.route('/login', methods=['GET', 'POST'])
def login():
    form = LoginForm()
    if form.validate_on_submit():
        user = User.query.filter_by(username=form.username.data).first()
        if user and user.password == form.password.data:
            session['username'] = user.username  # Store the username in the session
            flash('Login successful!', 'success')
            return redirect(url_for('dashboard'))
        else:
            flash('Login unsuccessful. Please check your username and password.', 'danger')
    return render_template('login.html', form=form)

@app.route('/logout', methods=['POST'])
def logout():
    # Clear the session to log out the user
    session.clear()
    flash('You have been logged out.', 'success')
    return redirect(url_for('login'))

# check if any of the Vms is running first 
def is_vm_running(vm_name):
    process = subprocess.run(['VBoxManage', 'showvminfo', vm_name], capture_output=True, text=True)
    return 'running' in process.stdout

def start_vm(vm_name):
    # type 'headless' , 'gui'
    process = subprocess.run(['VBoxManage', 'startvm', vm_name, '--type', 'gui'], capture_output=True, text=True)
    return process.returncode
    # process = subprocess.run(['VBoxManage', 'startvm', vm_name], capture_output=True, text=True)
    # return process.returncode

def start_sandbox_vms():
    log_messages = []

    # Check if Remnux VM is already running
    if is_vm_running(remnux_vm):
        log_messages.append(f'{remnux_vm} is already running.')
    else:
        # Start Remnux VM in headless mode
        if start_vm(remnux_vm) == 0:
            log_messages.append(f'{remnux_vm} started successfully.')
        else:
            log_messages.append(f'Failed to start {remnux_vm}.')

    # Check if Flarevm VM is already running
    if is_vm_running(flare_vm):
        log_messages.append(f'{flare_vm} is already running.')
    else:
        # Start Flarevm VM in headless mode
        if start_vm(flare_vm) == 0:
            log_messages.append(f'{flare_vm} started successfully.')
        else:
            log_messages.append(f'Failed to start {flare_vm}.')

    flash('\n'.join(log_messages), 'success')

def get_vm_info():
    # Retrieve VM information using VBoxManage
    command = 'VBoxManage list runningvms'
    process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    output, error = process.communicate()

    if process.returncode == 0:
        # Parse the output to get VM information
        vm_lines = output.decode('utf-8').split('\n')
        vm_info = [{'name': line.split(' ')[0].strip('"'), 'status': 'Running'} for line in vm_lines if line]
    else:
        # Handle the case where VBoxManage command fails
        flash(f'Failed to retrieve VM information. Error: {error.decode("utf-8")}', 'danger')
        vm_info = []

    # Add more VMs as needed
    vm_info.extend([
        {'name': 'remnux_vm', 'status': 'Stopped'},  # Update with your VM names
        {'name': 'flare_vm', 'status': 'Stopped'},
        # Add more VMs as needed
    ])

    return vm_info

# Example route for viewing VM
@app.route('/view_vm/<string:vm_name>')
def view_vm(vm_name):
    session_info = get_session_info(vm_name)
    return render_template('view_vm.html', session_info=session_info)

import json

def get_session_info(vm_name):
    # Implement logic to get session information
    command = f'VBoxManage showvminfo {vm_name} --machinereadable'
    result = subprocess.run(command, capture_output=True, text=True, shell=True)
    output_lines = result.stdout.split('\n')

    session_info = {}

    for line in output_lines:
        if '=' in line:
            key, value = line.split('=', 1)
            session_info[key.strip()] = value.strip()

    return session_info

    
# Example route for starting VM
@app.route('/start_vm/<string:vm_name>')
def start_vm_route(vm_name):
    # Call the start_vm function
    return_code = start_vm(vm_name)

    # Check the return code to see if starting the VM was successful
    if return_code == 0:
        flash(f'Started VM: {vm_name}', 'success')
    else:
        flash(f'Failed to start VM: {vm_name}', 'danger')

    # Redirect back to the dashboard
    return redirect(url_for('dashboard'))

# Example route for stopping VM
@app.route('/stop_vm/<string:vm_name>', methods=['POST'])
def stop_vm(vm_name):
    # Implement logic to stop/shutdown the VM
    # Use acpipowerbutton for a graceful shutdown
    command = f'VBoxManage controlvm {vm_name} acpipowerbutton'
    
    # Run the command
    process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    _, error = process.communicate()

    if process.returncode == 0:
        flash(f'The VM {vm_name} has been successfully stopped.', 'success')
    else:
        flash(f'Failed to stop the VM {vm_name}. Error: {error.decode("utf-8")}', 'danger')

    # Redirect back to the dashboard page after stopping the VM
    return redirect(url_for('dashboard'))

@app.route('/start_sandbox', methods=['POST'])
def start_sandbox():
    start_sandbox_vms()
    return redirect(url_for('dashboard'))


if __name__ == '__main__':
    with app.app_context():
        db.create_all()
    app.run(debug=True, port=5001)