from flask import Flask, render_template, redirect, url_for, flash, request, session
from flask_sqlalchemy import SQLAlchemy
from flask_wtf import FlaskForm
from wtforms import StringField, PasswordField, SubmitField
from wtforms.validators import DataRequired, Length
import os
import subprocess 
import pygetwindow as gw

import logging
from logging.handlers import RotatingFileHandler
# from flask_fontawesome import FontAwesome

from models import db, User
from forms import RegistrationForm, LoginForm, UploadForm  # Add this line to import the form classes


# Some default / base configurations 
app = Flask(__name__)
app.config['SECRET_KEY'] = 'your_secret_key'
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///site.db'
app.config['UPLOAD_FOLDER'] = 'uploads'
db.init_app(app)

remnux_vm='REMnux'
flare_vm='Flarevm'

# Configure logging
logging.basicConfig(level=logging.INFO)
handler = RotatingFileHandler('app.log', maxBytes=10000, backupCount=1)
handler.setLevel(logging.INFO)
app.logger.addHandler(handler)

# ROUTING TO THE VARIOUS PAGES
@app.route('/')
def home():
    if 'username' in session:
        # Redirect to the dashboard or another page for logged-in users
        return redirect(url_for('dashboard'))
    return redirect(url_for('login'))
@app.route('/autoscan')
def autoscan():
    output = request.args.get('output', '')
    return render_template('autoscan.html', output=output)

@app.route('/history')
def history():
    # Add your logic for the History page here
    return render_template('history.html')

@app.route('/dashboard', methods=['GET', 'POST'])
def dashboard():
    upload_form = UploadForm()

    if request.method == 'POST' and upload_form.validate_on_submit():
        malware_file = request.files['malware_file']

        if malware_file:
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], malware_file.filename)
            malware_file.save(file_path)
            flash(f'Malware file "{malware_file.filename}" uploaded successfully!', 'success')
        else:
            flash('No file selected for upload.', 'danger')

     # Get information about VMs
    vm_info = get_vm_info()

    return render_template('dashboard.html', upload_form=upload_form, vm_info=vm_info)


# --- START AUTOSCAN PAGE  ----:
from werkzeug.utils import secure_filename

# Define a function to check if the file is allowed
ALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'}

def allowed_file(filename):
    # [for specific file types ]
    # return '.' in filename and \
    #        filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS
    # [ For all file types ]
    return True  # Allow all file extensions


@app.route('/upload_file', methods=['POST'])
def upload_file():
    if 'file' not in request.files:
        flash('No file part', 'error')
        return redirect(request.url)
    
    file = request.files['file']
    
    if file.filename == '':
        flash('No selected file', 'error')
        return redirect(request.url)
    
    if file and allowed_file(file.filename):
        filename = secure_filename(file.filename)
        try:
            file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))
            flash('File uploaded successfully', 'success')
            app.logger.info(f"File '{filename}' saved to uploads folder")
            return redirect(url_for('autoscan', filename=filename))
        except Exception as e:
            app.logger.error(f"Error saving file '{filename}': {e}")
            flash('Error uploading file', 'error')
            return redirect(request.url)
    else:
        flash('Invalid file type', 'error')
        return redirect(request.url)



@app.route('/start_scan/<path:filename>')
def start_scan(filename):
    # Get the full path of the uploaded file
    file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
    
    # Check if the file exists
    if not os.path.exists(file_path):
        return jsonify({'error': 'File not found'}), 404
    
    # Run vtclient.py with the file path
    process = subprocess.run(["python", "vtclient.py", "-f", file_path], capture_output=True, text=True)
    output = process.stdout
    
    return render_template('autoscan.html', output=output)
    # return redirect(url_for('autoscan', output=output))

# --- AUTOSCAN PAGE END ----:


@app.route('/register', methods=['GET', 'POST'])
def register():
    form = RegistrationForm()

    if form.validate_on_submit():
        existing_user = User.query.filter_by(username=form.username.data).first()

        if existing_user:
            flash('Username is already taken. Please choose a different one.', 'danger')
        else:
            user = User(username=form.username.data, password=form.password.data)
            db.session.add(user)
            db.session.commit()
            flash('Your account has been created! You can now log in.', 'success')
            return redirect(url_for('login'))

    return render_template('register.html', form=form)


@app.route('/login', methods=['GET', 'POST'])
def login():
    form = LoginForm()
    if form.validate_on_submit():
        user = User.query.filter_by(username=form.username.data).first()
        if user and user.password == form.password.data:
            session['username'] = user.username  # Store the username in the session
            flash('Login successful!', 'success')
            return redirect(url_for('dashboard'))
        else:
            flash('Login unsuccessful. Please check your username and password.', 'danger')
    return render_template('login.html', form=form)

@app.route('/logout', methods=['POST'])
def logout():
    # Clear the session to log out the user
    session.clear()
    flash('You have been logged out.', 'success')
    return redirect(url_for('login'))

# check if any of the Vms is running first 
def is_vm_running(vm_name):
    process = subprocess.run(['VBoxManage', 'showvminfo', vm_name], capture_output=True, text=True)
    return 'running' in process.stdout

def start_vm(vm_name):
    # type 'headless' , 'gui'
    process = subprocess.run(['VBoxManage', 'startvm', vm_name, '--type', 'gui'], capture_output=True, text=True)
    return process.returncode
    # process = subprocess.run(['VBoxManage', 'startvm', vm_name], capture_output=True, text=True)
    # return process.returncode

def start_sandbox_vms():
    log_messages = []

    # Check if Remnux VM is already running
    if is_vm_running(remnux_vm):
        log_messages.append(f'{remnux_vm} is already running.')
    else:
        # Start Remnux VM in headless mode
        if start_vm(remnux_vm) == 0:
            log_messages.append(f'{remnux_vm} started successfully.')
        else:
            log_messages.append(f'Failed to start {remnux_vm}.')

    # Check if Flarevm VM is already running
    if is_vm_running(flare_vm):
        log_messages.append(f'{flare_vm} is already running.')
    else:
        # Start Flarevm VM in headless mode
        if start_vm(flare_vm) == 0:
            log_messages.append(f'{flare_vm} started successfully.')
        else:
            log_messages.append(f'Failed to start {flare_vm}.')

    flash('\n'.join(log_messages), 'success')

def get_vm_info():
    # Retrieve VM information using VBoxManage
    command = 'VBoxManage list runningvms'
    process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    output, error = process.communicate()

    if process.returncode == 0:
        # Parse the output to get VM information
        vm_lines = output.decode('utf-8').split('\n')
        vm_info = [{'name': line.split(' ')[0].strip('"'), 'status': 'Running'} for line in vm_lines if line]
    else:
        # Handle the case where VBoxManage command fails
        flash(f'Failed to retrieve VM information. Error: {error.decode("utf-8")}', 'danger')
        vm_info = []

    # Add more VMs as needed
    vm_info.extend([
        {'name': 'remnux_vm', 'status': 'Stopped'},  # Update with your VM names
        {'name': 'flare_vm', 'status': 'Stopped'},
        # Add more VMs as needed
    ])

    return vm_info

# Example route for viewing VM
@app.route('/view_vm/<string:vm_name>')
def view_vm(vm_name):
    session_info = get_session_info(vm_name)
    return render_template('view_vm.html', session_info=session_info)

import json

def get_session_info(vm_name):
    # Implement logic to get session information
    command = f'VBoxManage showvminfo {vm_name} --machinereadable'
    result = subprocess.run(command, capture_output=True, text=True, shell=True)
    output_lines = result.stdout.split('\n')

    session_info = {}

    for line in output_lines:
        if '=' in line:
            key, value = line.split('=', 1)
            session_info[key.strip()] = value.strip()

    return session_info

    
# Example route for starting VM
@app.route('/start_vm/<string:vm_name>')
def start_vm_route(vm_name):
    # Call the start_vm function
    return_code = start_vm(vm_name)

    # Check the return code to see if starting the VM was successful
    if return_code == 0:
        flash(f'Started VM: {vm_name}', 'success')
    else:
        flash(f'Failed to start VM: {vm_name}', 'danger')

    # Redirect back to the dashboard
    return redirect(url_for('dashboard'))

# Example route for stopping VM
@app.route('/stop_vm/<string:vm_name>', methods=['POST'])
def stop_vm(vm_name):
    # Implement logic to stop/shutdown the VM
    # Use acpipowerbutton for a graceful shutdown
    command = f'VBoxManage controlvm {vm_name} acpipowerbutton'
    
    # Run the command
    process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    _, error = process.communicate()

    if process.returncode == 0:
        flash(f'The VM {vm_name} has been successfully stopped.', 'success')
    else:
        flash(f'Failed to stop the VM {vm_name}. Error: {error.decode("utf-8")}', 'danger')

    # Redirect back to the dashboard page after stopping the VM
    return redirect(url_for('dashboard'))

@app.route('/start_sandbox', methods=['POST'])
def start_sandbox():
    start_sandbox_vms()
    return redirect(url_for('dashboard'))


if __name__ == '__main__':
    with app.app_context():
        db.create_all()
    app.run(debug=True, port=5001)